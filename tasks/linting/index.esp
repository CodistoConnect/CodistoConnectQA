var Github = Server.Import("/include/github.esp");
var Secret = Application.GITHUBWEBHOOKSECRET;
var SlackRoomToken = Application.SLACKROOMTOKEN;
var Logger = Server.Import("/include/log.esp");

if (!Github.Hooks.pull(/^\/linting\/lint/, Secret, function (Hook) {

		//Github meta data we are interested in
		var PullRequestNumber = Hook.number;
		var Repo = Hook.repo.toLowerCase();
		var FilesMap = Github.PullRequests.Files(PullRequestNumber);

		//Report state
		var LintResults = {status: 200};
		var Report = [];
		var StaticAnalysisPass = false;
		var Warnings = false;
		var Errors = false;

		var Lint;
		switch(Repo) {
			case "codistoconnect" :
				Lint = Server.Import("/tasks/linting/php/linter.esp");
			default:
				Lint = Server.Import("/tasks/linting/bondi/linter.esp")[FilesMap];

		}

		switch (Hook.action) {
			case "assigned" :
				break;
			case "unassigned" :
				break;
			case "labeled" :
				break;
			case "unlabeled" :
				break;
			case "reopened":
				//lint all over again
			case "synchronize":
				//fall through - another push to the branch the pull request is tracking
			case "opened" :

				LintResults = Lint(Hook.sha1);

				if (LintResults.status == 200) {

					if (LintResults.warnings.length > 0 || LintResults.errors.length > 0) {

						var ChangeSetWarnings = 0;

						//Get list of files in this pull request - the linter may find erroneous files not part of this changeset. Discard
						//var FilesMap = Github.PullRequests.Files(PullRequestNumber);

						//TODO move the language report specific generation stuff into each language specific module

						Report.push("<h4>Configuration</h4>");
						Report.push("");
						Report.push("- [x] PHP Minimimum version (" + MIN_PHP + ") compatibility check");
						Report.push("<br>");
						Report.push("");


						var CheckinChangeset = function(Set) {

							for(let i = 0; i < Set.length; i++) {

								var LogRow = Set[i];
								var FileName = LogRow.filename;

								//There is at least one applicable file
								if (FileName in FilesMap)
									return 1;

							}

							return 0;

						};

						var AppendReport = function(Class, Collection) {

							Report.push("<h4>" + Class + "</h4>");

							var CurrentFileName = "";

							Collection.forEach(function(LogRow) {

								var FileName = LogRow.filename;

								if (FileName in FilesMap) {

									var BlobURL = FilesMap[FileName].blob_url;

									if(FileName != CurrentFileName) {

										Report.push("");
										Report.push('<h5><a href="' + BlobURL + '"</a>' + FileName + '</h5>');
										Report.push("|Line  | Error |");
										Report.push("|------| ------|");

										CurrentFileName = FileName;
									}

									var LineRef = BlobURL + "#L" + LogRow.line;
									Report.push('|<a href="' + LineRef +'">' + LogRow.line + '</a>|' + LogRow.text + '|');

								}

							});

							Report.push("<br>");
						};

						var ChangeSetErrors = LintResults.errors.length > 0 && CheckinChangeset(LintResults.errors);
						var ChangeSetWarnings = LintResults.warnings.length > 0 && CheckinChangeset(LintResults.warnings);

						if(ChangeSetErrors) {

							AppendReport('<a href="https://github.com/squizlabs/PHP_CodeSniffer">Phpcs</a> Errors', LintResults.errors);

						}

						if(ChangeSetWarnings) {

							AppendReport('<a href="https://github.com/squizlabs/PHP_CodeSniffer">Phpcs</a> Warnings', LintResults.warnings);

						}

						StaticAnalysisPass = ChangeSetErrors == 0 && ChangeSetWarnings == 0;

					} else {

						//No errors or warnings at all. Lovely
						StaticAnalysisPass = true;

					}

					Report.push("<h4>Summary</h4>");

					if(StaticAnalysisPass)
						Report.push("- [x] Static analysis passed");
					else
						Report.push("- [x] Static analysis failed");


					if(ChangeSetWarnings > 0)
						Report.push("- [x] Warnings were triggered");

					if(ChangeSetErrors > 0)
						Report.push("- [x] Errors were triggered");


					//If there were errors add hints
					if(!StaticAnalysisPass) {

						Report.push("");
						Report.push("<h4>Tips</h4>");
						Report.push("");

						Report.push("```php");
						Report.push("//To suppress analysis surround with the following directives")
						Report.push("//@codingStandardsIgnoreStart");
						Report.push("//Code to be ignored by phpcs ..")
						Report.push("//@codingStandardsIgnoreEnd");
						Report.push("```");

					}

					var Comments = Github.PullRequests.Comments(PullRequestNumber);
					Comments.map(function(Comment){

						//Delete any comments left previously by the codistobot
						if(Comment.commenter_login == "codistobot") {

							Github.PullRequests.DeleteComment(Comment.id);

						}
					});

					//Leave final review comment
					Github.PullRequests.Comment(PullRequestNumber, Report.join("\n"));

					var Labels = Github.Labels.ListIssue(PullRequestNumber);

					//Update label state
					if (!StaticAnalysisPass) {
						if(!("static analysis failed" in Labels))
							Github.Labels.Add(PullRequestNumber, "static analysis failed");

						if("static analysis passed" in Labels)
							Github.Labels.Remove(PullRequestNumber, "static analysis passed");

					} else {

						if(!("static analysis passed" in Labels))
							Github.Labels.Add(PullRequestNumber, "static analysis passed");

						if("static analysis failed" in Labels)
							Github.Labels.Remove(PullRequestNumber, "static analysis failed");
					}


				}

				break;

			case "reopened":
				break;

		}

		Response.Status = LintResults.status;
		Response.Write(Response.Status == 200 ? "OK" : "Error");

	})) {

}

Github.Hooks.process();
