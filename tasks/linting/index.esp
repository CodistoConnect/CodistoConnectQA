var Github = Server.Import("/include/github.esp");

var Secret = Application.GITHUBWEBHOOKSECRET;
var SlackRoomToken = Application.SLACKROOMTOKEN;
var Logger = Server.Import("/include/log.esp");

var MIN_PHP="5";


var Lint = function(SHA1) {

	var Status = 403;
	var Errors = [];
	var Warnings = [];
	var PluginPath = "";

	try {

		var FCGIReq = new FastCGIClient();
		FCGIReq.Open("POST", "fastcgi://127.0.0.1:6972/phplinter?phpversion=" + MIN_PHP + "&stashpop=1&sha1=" + SHA1);
		FCGIReq.Send();



		if(FCGIReq.Status == 200) {

			var ResponseBody = FCGIReq.ResponseBody.split("\n");
			PluginPath = ResponseBody[ResponseBody.length - 2] + "/";

			Status = FCGIReq.Status;
			var FileNameToken = "FILE: ";
			var FileName;

			for(var i = 0 ; i < ResponseBody.length; i++) {

				var Line = ResponseBody[i];

				if(Line.indexOf(FileNameToken) == 0) {
					FileName = Line.substr(FileNameToken.length, Line.length - FileNameToken.length);
				}
				var LineTokens = Line.split("|");
				if(LineTokens.length == 3) {

					var Type = LineTokens[1].trim();

					switch(Type){
						case "ERROR":
							Errors.push({"filename" : FileName.replace(PluginPath, ""), "line": parseInt(LineTokens[0].trim(), 10), "text" : LineTokens[2]});
							break;
						case "WARNING":
							Warnings.push({"filename" : FileName.replace(PluginPath, ""), "line" : parseInt(LineTokens[0].trim(), 10), "text": LineTokens[2]});
							break;
					}
				}
			}
		}


	} catch(e) {
		Debug.LogInfo(e.toSource());
	}

	finally {

		return {
			"status" : Status,
			"errors" : Errors,
			"warnings" : Warnings,
			"pluginpath" : PluginPath
		};
	}

};

if (!Github.Hooks.pull(/^\/linting\/lint/, Secret, function (Hook) {

		var PullRequestNumber = Hook.number;
		var LintResults = {status: 200};

		switch (Hook.action) {
			case "assigned" :
				break;
			case "unassigned" :
				break;
			case "labeled" :
				break;
			case "unlabeled" :
				break;
			case "synchronize":
			//fall through - another push to the branch the pull request is tracking
			case "opened" :

				var Report = [];
				var StaticAnalyisisPass = false;
				var Warnings = false;
				var Errors = false;

				LintResults = Lint(Hook.sha1);

				if (LintResults.status == 200) {

					if (LintResults.warnings.length > 0 || LintResults.errors.length > 0) {

						//Get list of files in this pull request - the linter may find erroneous files not part of this changeset. Discard
						var FilesMap = Github.PullRequests.Files(PullRequestNumber);

						Report.push("<h4>Configuration</h4>");
						Report.push("- [x] PHP Minimimum version " + MIN_PHP);
						Report.push("<br>");

						var AppendReport = function(Class, Collection) {

							Report.push("<h4>" + Class.toUpperCase() + "</h4>");

							var CurrentFileName = "";

							Collection.forEach(function(LogRow) {

								var FileName = LogRow.filename;

								if(FileName != CurrentFileName) {

									Report.push("<br>");
									Report.push("");
									Report.push("<h5>" + FileName + "</h5>");
									Report.push("|Line  | Error |");
									Report.push("|------| ------|");
											
									CurrentFileName = FileName;
								}

								if (FileName in FilesMap) {

									var BlobURL = FilesMap[FileName].blob_url;
									var LineRef = BlobURL + "#L" + LogRow.line;

									Report.push("|<a href=" + LineRef + ">" + LogRow.line + "</a>|" + LogRow.text + "|");

								}

							});

							Report.push("<br>");
						};

						if(LintResults.errors.length > 0) {
							AppendReport("Phpcs Errors", LintResults.errors);
						}

						if(LintResults.warnings.length > 0) {
							AppendReport("Phpcs Warnings", LintResults.warnings);
						}

					} else {
						StaticAnalyisisPass = true;

					}

					Report.push("<h4>Summary</h4>");

					if(StaticAnalyisisPass)
						Report.push("- [x] Static analysis passed");
					else
						Report.push("- [x] Static analysis failed");


					if(LintResults.warnings.length > 0)
						Report.push("- [x] Warnings were triggered");

					if(LintResults.errors.length > 0)
						Report.push("- [x] Errors were triggered");

					var Comments = Github.PullRequests.Comments(PullRequestNumber);
					Debug.LogInfo("Comments are " + JSON.stringify(Comments));
					Comments.map(function(Comment){

						Debug.LogInfo("Comment is " + JSON.stringify(Comment));
						//Delete any comments left previously by the codistobot
						if(Comment.commenter_login == "codistobot") {
							Github.PullRequests.DeleteComment(Comment.id);
							Debug.LogInfo("Deleting bot comment");
						}
					});



					//Leave final review comment
					Github.PullRequests.Comment(PullRequestNumber, Report.join("\n"));


					var Labels = Github.Labels.ListIssue(PullRequestNumber);

					//Update label state
					if (LintResults.errors.length > 0 || LintResults.warnings.length > 0) {
						if(!("static analysis failed" in Labels))
							Github.Labels.Add(PullRequestNumber, "static analysis failed");

						if("static analysis passed" in Labels)
							Github.Labels.Remove(PullRequestNumber, "static analysis passed");

					} else {

						if(!("static analysis passed" in Labels))
							Github.Labels.Add(PullRequestNumber, "static analysis passed");

						if("static analysis failed" in Labels)
							Github.Labels.Remove(PullRequestNumber, "static analysis failed");
					}


				}

				break;

			case "reopened":
				break;

		}

		Response.Status = LintResults.status;
		Response.Write(Response.Status == 200 ? "OK" : "Error");

	})) {

}

Github.Hooks.process();






