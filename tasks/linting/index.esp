var Github = Server.Import("/include/github.esp");

var Secret = Application.GITHUBWEBHOOKSECRET;
var SlackRoomToken = Application.SLACKROOMTOKEN;
var Logger = Server.Import("/include/log.esp");

var MIN_PHP="5";


var Lint = function(SHA1) {

	var Status = 403;
	var Errors = [];
	var Warnings = [];
	var PluginPath = "";

	try {

		var FCGIReq = new FastCGIClient();
		FCGIReq.Open("POST", "fastcgi://127.0.0.1:6972/phplinter?phpversion=" + MIN_PHP + "&stashpop=1&sha1=" + SHA1);
		FCGIReq.Send();



		if(FCGIReq.Status == 200) {

			var ResponseBody = FCGIReq.ResponseBody.split("\n");
			PluginPath = ResponseBody[ResponseBody.length - 2] + "/";

			Status = FCGIReq.Status;
			var FileNameToken = "FILE: ";
			var FileName;

			for(var i = 0 ; i < ResponseBody.length; i++) {

				var Line = ResponseBody[i];

				if(Line.indexOf(FileNameToken) == 0) {
					FileName = Line.substr(FileNameToken.length, Line.length - FileNameToken.length);
				}
				var LineTokens = Line.split("|");
				if(LineTokens.length == 3) {

					var Type = LineTokens[1].trim();

					switch(Type){
						case "ERROR":
							Errors.push({"filename" : FileName.replace(PluginPath, ""), "line": parseInt(LineTokens[0].trim(), 10), "text" : LineTokens[2]});
							break;
						case "WARNING":
							Warnings.push({"filename" : FileName.replace(PluginPath, ""), "line" : parseInt(LineTokens[0].trim(), 10), "text": LineTokens[2]});
							break;
					}
				}
			}
		}


	} catch(e) {
		Debug.LogInfo(e.toSource());
	}

	finally {

		return {
			"status" : Status,
			"errors" : Errors,
			"warnings" : Warnings,
			"pluginpath" : PluginPath
		};
	}

};

if (!Github.Hooks.pull(/^\/linting\/lint/, Secret, function (Hook) {

		var PullRequestNumber = Hook.number;
		var LintResults = {status: 200};

		switch (Hook.action) {
			case "assigned" :
				break;
			case "unassigned" :
				break;
			case "labeled" :
				break;
			case "unlabeled" :
				break;
			case "synchronize":
			//fall through - another push to the branch the pull request is tracking
			case "opened" :

				var Report = [];
				var StaticAnalyisisPass = false;
				var Warnings = false;
				var Errors = false;

				LintResults = Lint(Hook.sha1);

				var F = File.Open("lintstatus.txt", "wt+");
				F.Write("\n\nLintStatus \n" + JSON.stringify(LintResults));

				if (LintResults.status == 200) {

					var Labels = Github.Labels.ListIssue(PullRequestNumber);
					F.Write("\n\nLabels currently on Pullrequestnumber (" + PullRequestNumber + " ) are " + JSON.stringify(Labels));

					if (LintResults.warnings.length > 0 || LintResults.errors.length > 0) {

						//Get list of files in this pull request
						Debug.LogInfo("Getting list of files for Pullrequest " + PullRequestNumber);

						var FilesMap = Github.PullRequests.Files(PullRequestNumber);
						F.Write("\n\nFiles in PullRequest are " + JSON.stringify(FilesMap));

						/*remember to fence code blocks with three backticks and php to do php syntax highlighting

						 ```php
						 ```

						//to generate nicely formatted comments
						 | First Header  | Second Header |
						 | ------------- | ------------- |
						 | Content Cell  | Content Cell  |
						 | Content Cell  | Content Cell  |

						 */

						/*
						Tasklists

						 - [x] list syntax is required (any unordered or ordered list supported)
						 - [x] this is a complete item
						 - [ ] this is an incomplete item
						 */


						Report.push("<h4>Configuration</h4>");
						Report.push("- [x] PHP Minimimum version " + MIN_PHP);
						Report.push("<br>");

						var AppendReport = function(Class, Collection) {

							Report.push("<h4>" + Class.toUpperCase() + "</h4>");

							var CurrentFileName = "";

							Collection.forEach(function(LogRow) {

								var FileName = LogRow.filename;

								if(FileName != CurrentFileName) {

									Report.push("<br>");
									Report.push("<h5>" + FileName + "</h5>");
									Report.push("|Line  | Error |");
									Report.push("|------| ------|");

									CurrentFileName = FileName;
								}

								if (FileName in FilesMap) {


									Report.push("|" + LogRow.line + "|" + LogRow.text + "|");

									//grab out the most recent filesha so that we can provide direct line links

									/*
									 https://github.com/CodistoConnect/CodistoConnect/pull/67/files#diff-18f0ae73d0c2499bbd47700ceb38bdffR36
									 I think the diff is probably the file sha which will come back
									 */
									//var FileCommitSha = FilesMap[FileName].sha;
								}

							});

							Report.push("<br>");
						};

						if(LintResults.errors.length > 0) {
							AppendReport("Errors", LintResults.errors);
						}

						if(LintResults.warnings.length > 0) {
							AppendReport("Warnings", LintResults.warnings);
						}

					} else {
						StaticAnalyisisPass = true;

					}

					Report.push("<h4>Summary</h4>");

					if(StaticAnalyisisPass)
						Report.push("- [x] Static analysis passed");
					else
						Report.push("- [x] Static analysis failed");


					if(LintResults.warnings.length > 0)
						Report.push("- [x] Warnings were triggered");

					if(LintResults.errors.length > 0)
						Report.push("- [x] Errors were triggered");


					//Update label state
					if (LintResults.errors.length > 0 || LintResults.warnings.length > 0) {

						Github.Labels.Add(PullRequestNumber, "static analysis failed");
						Github.Labels.Remove(PullRequestNumber, "static analysis passed");

					} else {
						Github.Labels.Add(PullRequestNumber, "static analysis passed");
						Github.Labels.Remove(PullRequestNumber, "static analysis failed");
					}

					//Leave final review comment
					Github.PullRequests.Comment(PullRequestNumber, Report.join("\n"));


				}

				for(var i = 0 ; i < Report.length; i++) {
					F.Write(Report[i] + "\n");
				}

				F.Close();

				break;

			case "reopened":
				break;

		}

		Response.Status = LintResults.status;
		Response.Write(Response.Status == 200 ? "OK" : "Error");

	})) {

}

Github.Hooks.process();






